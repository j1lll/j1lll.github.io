<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#cd433f">
  <meta name="description" content="Photo Editor Application"> 
  <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
  <link rel="stylesheet" href="./css/style.css" />
  <link rel="stylesheet" href="./css/range-input.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta2/css/all.min.css" />
  <link rel="manifest" href="/manifest.json" />
  <title>GENE</title>
</head>

<body>
  <div id="left">
    <H4>MATH IS THE BUILDING BLOCK OF LIFE</H4>
      <i id = "overview">
      Photo editing and photo storage is directly linked to linear algebra since images can be represented as matrices of pixels. Each pixel has an RGB value that is represented by a vector with an entry for each of the pixel's red, green, blue, and alpha (transparency) values. This webapp allows users to select one of three different photos to be displayed in the center of the page. This selection transfers the image data onto the canvas. From there, users can add filters to the image by clicking the buttons that are on the right side of the screen. When a filter is clicked, information regarding the link between the changes appearing on the canvas and linear algebra show up on the left side of the screen. 
      </i>
    <p id="all-text">
      
      <br>
      <strong>
        Grey Scale
      </strong>
      - the function performs a basic linear transformation on the pixel data array to convert the image to grayscale by setting the red, green, and blue components of each pixel to the average intensity.
      <br><br>
      <strong>Sepia / Lark</strong>
      - these functions apply scalar multiplication and addition to each pixel vector in the image's matrix of pixels in order to acheive the desired effect on the photo.
      <br><br>
      <strong>Flip</strong>
      - this filter flips the RGB values of each pixel, setting the new red value to the green value, the new green value to the blue value, and the new blue value to the red value
      - this is an example of performing a permutation operation on the color vectors since the colors' corresponding rows are being swapped around
      <br><br>
      <strong>Crumble</strong>
      - crumble utilizes matrix addition to effectively add a 'noise matrix' to each RGB value of each pixel of the image (conceptually, another matrix)
      <br><br>
      <strong>Blur</strong>
      -  the blur filter applies a convolution operation using a box blur matrix to compute the weighted sum of neighboring pixels, editing the image to have the blurred effect
    </p>

    <p id="grey-text">
      Linear algebra is employed in the greyscaling process of photo editing programs, particularly when the RGB values are averaged. To convert a color image to grayscale, each pixel's RGB values are averaged, resulting in a single grayscale intensity value. This averaging operation can be implemented using matrix operations. The image matrix, representing the RGB values, is multiplied by a conversion matrix that contains equal weights (1/3) for each color channel. This matrix multiplication performs the element-wise multiplication and accumulation necessary to compute the grayscale intensity values. The resulting matrix represents the greyscaled image, where each element corresponds to the averaged intensity value of the corresponding pixel in the original image. Linear algebra provides a concise and efficient way to perform this calculation, simplifying the greyscaling process in photo editing software.
    </p>

    <p id="sepia-text">   
      The sepia filter is a popular effect used in photo editing to give images a nostalgic or vintage appearance, mimicking the tone and feel of old-fashioned photographs. It adds a warm, brownish tint to the image, reminiscent of aged or sepia-toned prints.
      The sepia filter is typically applied by modifying the color values of the image, transforming the original RGB (Red, Green, Blue) color space. The exact algorithm for the sepia filter can vary, but a common approach involves adjusting the color channels to achieve the desired effect.
      To create a sepia filter, the red, green, and blue color values of each pixel are transformed. The red channel is increased, while the green and blue channels are decreased, resulting in a shift towards warm, brown tones. This adjustment is typically done using linear algebra operations, such as matrix multiplication and addition.
      By applying the sepia filter matrix to the image matrix, the color values of each pixel are transformed according to the desired algorithm. The resulting image has a sepia-toned appearance, evoking a nostalgic or vintage aesthetic.
    </p>

    <p id="lark-text">
      The Lark filter is a photo editing effect that imparts a soft, dreamy, and slightly desaturated look to images. Linear algebra is used to apply the Lark filter to photos by performing mathematical transformations on the pixel data. These transformations involve operations like brightness adjustment, RGB channel modification, and saturation changes. By using linear algebra techniques such as matrix multiplication and addition the color values of the image pixels are modified accordingly. These operations are applied to the image matrix, resulting in the desired visual effect of the Lark filter. Linear algebra provides a mathematical framework to efficiently and accurately apply the filter, allowing photo editing software to enhance images with a soft and muted appearance.
    </p>

    <p id="flip-text">
      Linear algebra is utilized in flipping the colors of photos by manipulating the pixel data through matrix operations. When flipping colors, linear algebra helps interchange or invert the color channels of the image, such as the red, green, and blue channels.
      To achieve color flipping, the image is represented as a matrix of pixels, with each pixel containing color information in the form of RGB values. Linear algebra operations, like matrix multiplication and addition, are applied to transform the pixel values.
      In the case of color flipping, a transformation matrix is created that swaps or inverts the color channels. By multiplying the original image matrix with this transformation matrix, the color values of each pixel are modified accordingly. The resulting matrix represents the flipped color image.
      For example, to invert the colors, a transformation matrix can be defined with negative coefficients for each color channel. By multiplying this matrix with the image matrix, the colors are effectively inverted.
    </p>


    <p id="crumble-text">
      Crumbling, or fractal noise generation, is a technique in photo editing that adds texture and visual interest to an image. Linear algebra is involved in this process to create the crumbling effect by introducing random variations to the image.
      To achieve crumbling, a random noise matrix is generated, typically consisting of values within a specific range. This noise matrix represents the random variations that will be added to the image. Both the image matrix and the noise matrix have the same dimensions.
      Linear algebra comes into play by performing matrix addition. Each element of the noise matrix is added to the corresponding element in the image matrix using matrix addition. This operation combines the random variations from the noise matrix with the original image, creating a new matrix that incorporates the crumbling effect.
      The use of matrix addition allows the random variations to be seamlessly integrated into the image, enhancing its visual appearance. By adjusting the properties of the noise matrix, such as the range of values or the pattern of randomness, different levels of crumbling effects can be achieved.
    </p>

    <p id="blur-text">
      Blurring involves manipulating pixel values to reduce sharpness and create a smoother appearance of an image. Matrices are used to achieve this effect. Blurring is a convolution operation where each pixel is combined with its neighboring pixels. This combination is performed by applying a convolution matrix to the image. The convolution matrix contains weights that determine the contribution of each pixel to the blurred result. Linear algebra enables efficient computation of the convolution process. Matrix multiplication and summation operations are utilized to apply the filter to the image. The matrix operations aggregate pixel values, considering their respective weights, to generate the new blurred pixel values. By carefully designing the convolution matrix, different blurring effects can be achieved. Here, we are using a simple box blur that assigns equal weights to all neighboring pixels, resulting in a uniform blurring effect. Other types of blurs, such as Gaussian blur, use convolution matrices that follow specific mathematical distributions to create a smoother, cleaner blur.
    </p>
  </div> 

  <div id="middle">
    <div class="canvas">
      <canvas class="img-box" id="img-box"> </canvas>
      <div class="uploaded-img-container">
        <p class="select">select a photo</p>
      </div>

      <!-- Thumbnail photos -->
      <div class=thumbnails>
        <button class="photo-button">
          <img class="thumbnail-image" src="/assets/images/logo.JPG" alt="Thumbnail 1">
        </button>
        <button class="photo-button">
          <img class="thumbnail-image" src="/assets/images/gambling_gene.webp" alt="Thumbnail 2">
        </button>
        <button class="photo-button">
          <img class="thumbnail-image" src="/assets/images/lecture_gene.jpeg" alt="Thumbnail 3">
        </button>
      </div>

      <div id="dos">
       
        <!-- <div id="Clear"> -->
        <button class="Clear" onclick="applyFilter('remove')">
          <input type="file" id="input-field" accept="image/png, image/jpeg" hidden />
          <i id="delete" id="close-btn"
              class="fas fa-close"></i></i><span>&nbsp; Clear</span></a>
        </button>
        <!-- </div> -->
        
      </div>
    </div>

    
  
      </div>
    </div>
 
  </div>
  <div id="right">
    <div id="tools">
      <h4>FILTERS</h4>
      <button id="grey-scale" class="filter-button" data="grey">grey</button>
      <button id="sepia" class="filter-button" data="sepia">sepia</button>
      <button id="lark" class="filter-button" data="lark">lark</button>
      <button id="flip" class="filter-button" data="flip">flip</button>
      <button id="crumble" class="filter-button" data="crumble">crumble</button>
      <button id="blur" class="filter-button" data="blur">blur</button>
      
    </div>
  </div>
  <script src="./js/app.js"></script>
  <script>
    for (let e of document.querySelectorAll(
      'input[type="range"].slider-progress'
    )) {
      e.style.setProperty("--value", e.value);
      e.style.setProperty("--min", e.min == "" ? "0" : e.min);
      e.style.setProperty("--max", e.max == "" ? "100" : e.max);
      e.addEventListener("input", () =>
        e.style.setProperty("--value", e.value)
      );
    }
  </script>

  <script>
    if('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./serviceworker.js')
          .then((reg) => console.log('Success: ', reg.scope))
          .catch((err) => console.log('Failure: ', err))
      })
    }
  </script>
</body>

</html>